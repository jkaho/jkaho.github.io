import EventEmitter from "./events";
export { EventEmitter };
/**
 * NetworkError defines an error occuring from the network.
 */
export declare class NetworkError extends Error {
    type: "CONNECTION";
    constructor(message: string);
}
/**
 * RequestError defines an error occuring from a request.
 */
export declare class RequestError extends Error {
    statusCode: number;
    error?: Error;
    constructor(statusCode: number, message: string, error?: Error);
}
/**
 * Client defines a client for interacting with the Sajari API.
 */
export declare class Client {
    project: string;
    collection: string;
    endpoint: string;
    key?: string;
    secret?: string;
    userAgent: string;
    /**
     * Constructs an instance of Client for a specific project and collection.
     *
     * ```javascript
     * const client = new Client("<project>", "<collection>");
     * ```
     *
     * It is also possible to optionally set the api endpoint
     *
     * ```javascript
     * const client = new Client("<project>", "<collection>", "<endpoint>");
     * ```
     *
     * @param project
     * @param collection
     * @param {string} [endpoint]
     */
    constructor(project: string, collection: string, endpoint?: string, key?: string, secret?: string);
    /**
     * call executes a request to the Sajari API
     */
    call<Response = any>(path: string, request: Record<string, any>, signal?: AbortSignal): Promise<Response>;
    /**
     * pipeline creates a new QueryPipeline instance that inherits configuration from the Client.
     * @param name pipeline name
     * @param {string} [version] pipeline version
     */
    pipeline(name: string, version?: string): QueryPipeline;
    /**
     * interactionConsume consumes an interaction token.
     */
    interactionConsume(token: string, identifier: string, weight: number, data?: Record<string, string>): Promise<void>;
}
/**
 * Type of pipeline.
 */
export declare enum PipelineType {
    /**
     * Query pipeline.
     */
    Query = 1,
    /**
     * Record pipeline.
     */
    Record = 2
}
export interface Step {
    identifier: string;
    title?: string;
    description?: string;
    parameters?: {
        [name: string]: {
            name?: string;
            defaultValue?: string;
        };
    };
    constants?: {
        [name: string]: {
            value?: string;
        };
    };
    condition?: string;
}
/**
 * Pipeline ...
 */
export interface Pipeline {
    identifier: PipelineIdentifier;
    created: Date;
    description?: string;
    steps: {
        preSteps: Step[];
        postSteps: Step[];
    };
}
/**
 * PipelineIdentifier ...
 */
export interface PipelineIdentifier {
    name: string;
    version?: string;
}
export declare const EVENT_SEARCH_SENT = "search-sent";
/**
 * QueryPipeline is a client for running query pipelines on a collection.  See
 * [[QueryPipeline.search]] for more details.
 *
 * Create a new QueryPipeline via [[Client.pipeline]].
 *
 * ```javascript
 * // const client = new Client(...);
 * const pipeline = client.pipeline("website");
 * ```
 */
declare class QueryPipeline extends EventEmitter {
    private client;
    readonly identifier: PipelineIdentifier;
    constructor(client: Client, name: string, version?: string);
    /**
     * Search runs a search query defined by a pipeline with the given values and
     * session configuration.
     *
     * ```javascript
     * pipeline.search({ q: "<search query>" })
     *  .then(([response, values]) => {
     *    // handle response
     *  })
     *  .catch(error => {
     *    // handle error
     * })
     * ```
     *
     * @param values
     * @param tracking
     */
    search(values: Record<string, string>, tracking?: Tracking): Promise<[SearchResponse, Record<string, string>]>;
}
export interface SearchResponse {
    /**
     * Time in seconds taken to perform the query.
     */
    time: number;
    /**
     * totalResults is the total number of results.
     */
    totalResults: number;
    /**
     * Results of the query.
     */
    results: Result[];
    /**
     * Aggregates computed on the query results (see [[Aggregates]]).
     */
    aggregates: Aggregates;
    /**
     * AggregateFilters computed on the query results (see [[Aggregates]]).
     */
    aggregateFilters: Aggregates;
}
export interface Result {
    /**
     * indexScore is the index-matched score of this Result.
     */
    indexScore: number;
    /**
     * score is the overall score of this [[Result]].
     */
    score: number;
    /**
     * values is an object of field-value pairs.
     */
    values: Record<string, string | string[]>;
    /**
     * token is the [[Token]] associated with this [[Result]] (if any).
     */
    token?: Token;
}
export declare type Token = ClickToken | PosNegToken;
/**
 * ClickToken defines a click token.  See [[TrackingType.Click]] for more details.
 */
export declare type ClickToken = {
    click: string;
};
/**
 * PosNegToken defines a pos/neg token pair. See [[TrackingType.PosNeg]] for more details.
 */
export declare type PosNegToken = {
    pos: string;
    neg: string;
};
export declare type Aggregates = Record<string, Record<string, CountAggregate | MetricAggregate>>;
export interface CountAggregate {
    count: Record<string, number>;
}
export declare type MetricAggregate = number;
/**
 * Tracking defines behaviour for handling search sessions and result interactions.
 */
export declare type Tracking = {
    type: TrackingType;
    queryID?: string;
    sequence?: number;
    field?: string;
    data?: Record<string, string>;
};
/**
 * TrackingType defines the possible result-interaction tracking types used by [[Session]]
 */
export declare enum TrackingType {
    /**
     * None disables tracking.
     */
    None = "NONE",
    /**
     * Click generates click tracking tokens.
     */
    Click = "CLICK",
    /**
     * PosNeg creates pos/neg tracking tokens.
     */
    PosNeg = "POS_NEG"
}
/**
 * Session takes query values, maintains session state, and returns tracking data
 * to be sent with search requests.
 */
export interface Session {
    /**
     * next returns [[Tracking]] to be sent with search requests.
     * @param values
     */
    next(values?: Record<string, string>): Tracking;
    /**
     * reset sets the [[Session]] instance to its empty state.
     */
    reset(): void;
}
export declare const EVENT_TRACKING_RESET = "tracking-reset";
/**
 * DefaultSession holds state of a sequence of searches.
 */
export declare class DefaultSession extends EventEmitter implements Session {
    private queryID;
    private sequence;
    private type;
    private field?;
    private data?;
    constructor(type: TrackingType, field?: string, data?: Record<string, string>);
    next(_?: Record<string, string>): Tracking;
    reset(): void;
}
/**
 * InteractiveSession creates a session based on text searches and is recommended
 * for use in search-as-you-type style interfaces.
 *
 * It resets the session if the search query value:
 *
 * - Is `undefined`.
 * - First 3 characters have changed (i.e. from a direct replacement)
 * - Cleared after being non-empty (i.e. from a delete)
 */
export declare class InteractiveSession implements Session {
    private session;
    private textParam;
    private lastQuery;
    constructor(textParam: string, session: Session);
    next(values: Record<string, string>): Tracking;
    reset(): void;
}
declare type FilterFunc = () => string;
export declare const EVENT_SELECTION_UPDATED = "selection-updated";
export declare const EVENT_OPTIONS_UPDATED = "options-updated";
export declare class Filter extends EventEmitter {
    private options;
    private active;
    private multi;
    private joinOp;
    constructor(options: Record<string, string>, initial?: string[], multi?: boolean, joinOp?: "OR" | "AND");
    set(key: string, active?: boolean): void;
    isActive(key: string): boolean;
    get(): string[];
    updateOptions(options: Record<string, string | FilterFunc | undefined>): void;
    getOptions(): Record<string, string | FilterFunc>;
    filter(): string;
}
export declare type ValueFunc = () => string;
export declare type ValueType = string | number | boolean | string[] | number[] | boolean[] | ValueFunc;
export declare const EVENT_VALUES_UPDATED = "values-changed";
export declare class Values extends EventEmitter {
    private internal;
    constructor(initial?: Record<string, ValueType>);
    _internalUpdate(values: Record<string, ValueType | undefined>): void;
    update(values: Record<string, ValueType | undefined>): void;
    get(): Record<string, string>;
}
