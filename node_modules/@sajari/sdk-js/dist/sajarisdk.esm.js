function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

/**
 * Check if we're in a server-side rendering context
 */
var isSSR = function isSSR() {
  return typeof window === "undefined";
};

var _document$currentScri;
var scriptTag = ! /*#__PURE__*/isSSR() ? (_document$currentScri = document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src : null;
var suffix = "";

if (scriptTag) {
  var source = /*#__PURE__*/new URL(scriptTag).host;
  suffix = "(via " + source + ")";
} else if (isSSR()) {
  suffix = "(SSR)";
}
/**
 * user agent of sdk
 * @hidden
 */


var USER_AGENT = /*#__PURE__*/["sajari-sdk-js/2.0.0-rc.2", suffix].filter(Boolean).join(" ");

var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    this.events = {};
  }

  var _proto = EventEmitter.prototype;

  _proto.emit = function emit(event) {
    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    if (this.events["*"]) {
      this.events["*"].forEach(function (cb) {
        return cb.apply(void 0, [event].concat(data));
      });
    }

    if (!this.events[event]) {
      return;
    }

    this.events[event].forEach(function (cb) {
      return cb.apply(void 0, data);
    });
  };

  _proto.on = function on(event, callback) {
    var _this = this;

    if (!this.events[event]) {
      this.events[event] = [];
    }

    this.events[event].push(callback);
    return function () {
      _this.events[event] = _this.events[event].filter(function (item) {
        return item !== callback;
      });
    };
  };

  return EventEmitter;
}();

/**
 * NetworkError defines an error occuring from the network.
 */

var NetworkError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(NetworkError, _Error);

  function NetworkError(message) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.type = "CONNECTION";
    return _this;
  }

  return NetworkError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * RequestError defines an error occuring from a request.
 */

var RequestError = /*#__PURE__*/function (_Error2) {
  _inheritsLoose(RequestError, _Error2);

  function RequestError(statusCode, message, error) {
    var _this2;

    _this2 = _Error2.call(this, message) || this;
    _this2.statusCode = statusCode;
    _this2.error = error;
    return _this2;
  }

  return RequestError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Client defines a client for interacting with the Sajari API.
 */

var Client = /*#__PURE__*/function () {
  /**
   * Constructs an instance of Client for a specific project and collection.
   *
   * ```javascript
   * const client = new Client("<project>", "<collection>");
   * ```
   *
   * It is also possible to optionally set the api endpoint
   *
   * ```javascript
   * const client = new Client("<project>", "<collection>", "<endpoint>");
   * ```
   *
   * @param project
   * @param collection
   * @param {string} [endpoint]
   */
  function Client(project, collection, endpoint, key, secret) {
    if (endpoint === void 0) {
      endpoint = (isSSR() ? "https:" : "") + "//jsonapi.sajari.net";
    }

    // Callers can set this to add an additional user agent value to the request's metadata.
    this.userAgent = ""; // Key/secret is only allowed in non SSR context

    if (!isSSR() && [key, secret].some(Boolean)) {
      throw new Error("key/secret authorization is only supported for server-side rendering.");
    }

    this.project = project;
    this.collection = collection;
    this.endpoint = endpoint;
    this.key = key;
    this.secret = secret;
    this.interactionConsume = this.interactionConsume.bind(this);
  }
  /**
   * call executes a request to the Sajari API
   */


  var _proto = Client.prototype;

  _proto.call = function call(path, request, signal) {
    try {
      var _this4 = this;

      // Check we have a connection in non SSR context
      if (!isSSR() && !navigator.onLine) {
        throw new NetworkError("Search request failed due to a network error. Please check your network connection.");
      }

      var metadata = {
        project: [_this4.project],
        collection: [_this4.collection],
        "user-agent": [[USER_AGENT, _this4.userAgent].filter(Boolean).join(" ")]
      }; // Only allow key/secret for SSR contexts

      if (isSSR() && [_this4.key, _this4.secret].every(Boolean)) {
        Object.assign(metadata, {
          authorization: ["keysecret " + _this4.key + " " + _this4.secret]
        });
      }

      return Promise.resolve(fetch("" + _this4.endpoint + path, {
        signal: signal,
        method: "POST",
        headers: {
          Accept: "application/json",
          // XXX: This is to remove the need for the OPTIONS request
          // https://stackoverflow.com/questions/29954037/why-is-an-options-request-sent-and-can-i-disable-it
          "Content-Type": "text/plain"
        },
        body: JSON.stringify({
          metadata: metadata,
          request: request
        })
      })).then(function (resp) {
        var _exit = false;

        function _temp4(_result) {
          return _exit ? _result : Promise.resolve(resp.json());
        }

        var _temp3 = function () {
          if (resp.status !== 200) {
            var _temp5 = function _temp5() {
              if (resp.status === 403) {
                throw new RequestError(resp.status, "This domain is not authorized to make this search request.", new Error(_message));
              }

              throw new RequestError(resp.status, "Search request failed due to a configuration error.", new Error(_message));
            };

            var _message = resp.statusText;

            var _temp6 = _catch(function () {
              return Promise.resolve(resp.json()).then(function (response) {
                _message = response.message;
              });
            }, function () {});

            return _temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6);
          }
        }();

        return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * pipeline creates a new QueryPipeline instance that inherits configuration from the Client.
   * @param name pipeline name
   * @param {string} [version] pipeline version
   */
  ;

  _proto.pipeline = function pipeline(name, version) {
    return new QueryPipeline(this, name, version);
  }
  /**
   * interactionConsume consumes an interaction token.
   */
  ;

  _proto.interactionConsume = function interactionConsume(token, identifier, weight, data) {
    if (data === void 0) {
      data = {};
    }

    try {
      var _this6 = this;

      return Promise.resolve(_this6.call("/sajari.interaction.v2.Interaction/ConsumeToken", {
        token: token,
        identifier: identifier,
        weight: weight,
        data: data
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return Client;
}();
/**
 * Type of pipeline.
 */

var PipelineType;

(function (PipelineType) {
  /**
   * Query pipeline.
   */
  PipelineType[PipelineType["Query"] = 1] = "Query";
  /**
   * Record pipeline.
   */

  PipelineType[PipelineType["Record"] = 2] = "Record";
})(PipelineType || (PipelineType = {}));

var EVENT_SEARCH_SENT = "search-sent";
/**
 * QueryPipeline is a client for running query pipelines on a collection.  See
 * [[QueryPipeline.search]] for more details.
 *
 * Create a new QueryPipeline via [[Client.pipeline]].
 *
 * ```javascript
 * // const client = new Client(...);
 * const pipeline = client.pipeline("website");
 * ```
 */

var QueryPipeline = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(QueryPipeline, _EventEmitter);

  function QueryPipeline(client, name, version) {
    var _this7;

    _this7 = _EventEmitter.call(this) || this;
    _this7.client = client;
    _this7.identifier = {
      name: name,
      version: version
    };
    return _this7;
  }
  /**
   * Search runs a search query defined by a pipeline with the given values and
   * session configuration.
   *
   * ```javascript
   * pipeline.search({ q: "<search query>" })
   *  .then(([response, values]) => {
   *    // handle response
   *  })
   *  .catch(error => {
   *    // handle error
   * })
   * ```
   *
   * @param values
   * @param tracking
   */


  var _proto2 = QueryPipeline.prototype;

  _proto2.search = function search(values, tracking) {
    try {
      var _this9 = this;

      var pt = {
        type: TrackingType.None
      };

      if (tracking !== undefined) {
        var queryID = tracking.queryID,
            rest = _objectWithoutPropertiesLoose(tracking, ["queryID"]);

        pt = _extends({
          query_id: queryID
        }, rest);
      }

      _this9.emit(EVENT_SEARCH_SENT, values);

      return Promise.resolve(_this9.client.call("/sajari.api.pipeline.v1.Query/Search", {
        pipeline: _this9.identifier,
        tracking: pt,
        values: values
      })).then(function (jsonProto) {
        var _jsonProto$searchResp, _jsonProto$searchResp2, _jsonProto$searchResp3, _jsonProto$searchResp4, _jsonProto$searchResp5;

        var aggregates = Object.entries(((_jsonProto$searchResp = jsonProto.searchResponse) === null || _jsonProto$searchResp === void 0 ? void 0 : _jsonProto$searchResp.aggregates) || {}).map(function (_ref) {
          var key = _ref[0],
              aggregate = _ref[1];

          if ("metric" in aggregate) {
            var _key$split = key.split("."),
                t = _key$split[0],
                k = _key$split[1];

            return {
              type: t,
              key: k,
              value: aggregate.metric.value
            };
          }

          if ("count" in aggregate) {
            return {
              type: "count",
              key: key.replace(/^count./, ""),
              value: aggregate.count.counts
            };
          }

          if ("buckets" in aggregate) {
            var _aggregate$buckets$bu, _aggregate$buckets;

            return {
              type: "count",
              key: "buckets",
              value: Object.values((_aggregate$buckets$bu = (_aggregate$buckets = aggregate.buckets) === null || _aggregate$buckets === void 0 ? void 0 : _aggregate$buckets.buckets) !== null && _aggregate$buckets$bu !== void 0 ? _aggregate$buckets$bu : {}).reduce(function (obj, _ref2) {
                var _Object$assign;

                var name = _ref2.name,
                    count = _ref2.count;
                return Object.assign(obj, (_Object$assign = {}, _Object$assign[name] = count, _Object$assign));
              }, {})
            };
          }

          return {
            key: key,
            value: aggregate
          };
        }).reduce(function (obj, item) {
          if (item.type === undefined) {
            console.debug(item);
            return obj;
          }

          if (obj[item.key] === undefined) {
            obj[item.key] = {};
          } // @ts-ignore


          obj[item.key][item.type] = item.value;
          return obj;
        }, {});
        var aggregateFilters = Object.entries(((_jsonProto$searchResp2 = jsonProto.searchResponse) === null || _jsonProto$searchResp2 === void 0 ? void 0 : _jsonProto$searchResp2.aggregateFilters) || {}).map(function (_ref3) {
          var key = _ref3[0],
              aggregate = _ref3[1];

          if ("metric" in aggregate) {
            var _key$split2 = key.split("."),
                t = _key$split2[0],
                k = _key$split2[1];

            return {
              type: t,
              key: k,
              value: aggregate.metric.value
            };
          }

          if ("count" in aggregate) {
            return {
              type: "count",
              key: key.replace(/^count./, ""),
              value: aggregate.count.counts
            };
          }

          if ("buckets" in aggregate) {
            var _aggregate$buckets$bu2, _aggregate$buckets2;

            return {
              type: "count",
              key: "buckets",
              value: Object.values((_aggregate$buckets$bu2 = (_aggregate$buckets2 = aggregate.buckets) === null || _aggregate$buckets2 === void 0 ? void 0 : _aggregate$buckets2.buckets) !== null && _aggregate$buckets$bu2 !== void 0 ? _aggregate$buckets$bu2 : {}).reduce(function (obj, _ref4) {
                var _Object$assign2;

                var name = _ref4.name,
                    count = _ref4.count;
                return Object.assign(obj, (_Object$assign2 = {}, _Object$assign2[name] = count, _Object$assign2));
              }, {})
            };
          }

          return {
            key: key,
            value: aggregate
          };
        }).reduce(function (obj, item) {
          if (item.type === undefined) {
            console.debug(item);
            return obj;
          }

          if (obj[item.key] === undefined) {
            obj[item.key] = {};
          } // @ts-ignore


          obj[item.key][item.type] = item.value;
          return obj;
        }, {});
        var results = (((_jsonProto$searchResp3 = jsonProto.searchResponse) === null || _jsonProto$searchResp3 === void 0 ? void 0 : _jsonProto$searchResp3.results) || []).map(function (_ref5, index) {
          var indexScore = _ref5.indexScore,
              score = _ref5.score,
              values = _ref5.values;
          var t = undefined;
          var token = (jsonProto.tokens || [])[index];

          if (token !== undefined) {
            if ("click" in token) {
              t = {
                click: clickTokenURL + token.click.token
              };
            } else if ("pos" in token) {
              t = _extends({}, token);
            } else if ("posNeg" in token) {
              t = {
                pos: token.posNeg.pos,
                neg: token.posNeg.neg
              };
            }
          }

          return {
            indexScore: indexScore,
            score: score,
            values: processProtoValues(values),
            token: t
          };
        });
        return [{
          time: parseFloat(((_jsonProto$searchResp4 = jsonProto.searchResponse) === null || _jsonProto$searchResp4 === void 0 ? void 0 : _jsonProto$searchResp4.time) || "0.0"),
          totalResults: parseInt(((_jsonProto$searchResp5 = jsonProto.searchResponse) === null || _jsonProto$searchResp5 === void 0 ? void 0 : _jsonProto$searchResp5.totalResults) || "0", 10),
          results: results,
          aggregates: aggregates,
          aggregateFilters: aggregateFilters
        }, jsonProto.values || {}];
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return QueryPipeline;
}(EventEmitter);
/**
 * Redirect URL for click tracking.  Prepended to the the front of the token
 * returned by the engine.
 * @hidden
 */


var clickTokenURL = "https://re.sajari.com/token/";
/**
 * @hidden
 */

function processProtoValues(values) {
  var vs = {};
  Object.keys(values).forEach(function (key) {
    var v = valueFromProto(values[key]);

    if (v !== null) {
      vs[key] = v;
    }
  });
  return vs;
}
/**
 * @hidden
 */


function valueFromProto(value) {
  if ("single" in value) {
    return value.single;
  } else if ("repeated" in value) {
    return value.repeated.values;
  }

  return null;
}
/**
 * TrackingType defines the possible result-interaction tracking types used by [[Session]]
 */


var TrackingType;

(function (TrackingType) {
  /**
   * None disables tracking.
   */
  TrackingType["None"] = "NONE";
  /**
   * Click generates click tracking tokens.
   */

  TrackingType["Click"] = "CLICK";
  /**
   * PosNeg creates pos/neg tracking tokens.
   */

  TrackingType["PosNeg"] = "POS_NEG";
})(TrackingType || (TrackingType = {}));

var EVENT_TRACKING_RESET = "tracking-reset";
/**
 * DefaultSession holds state of a sequence of searches.
 */

var DefaultSession = /*#__PURE__*/function (_EventEmitter2) {
  _inheritsLoose(DefaultSession, _EventEmitter2);

  function DefaultSession(type, field, data) {
    var _this10;

    _this10 = _EventEmitter2.call(this) || this;
    _this10.queryID = "";
    _this10.sequence = 0;
    _this10.type = type;
    _this10.field = field;
    _this10.data = mergeTrackingData(data);
    return _this10;
  }

  var _proto3 = DefaultSession.prototype;

  _proto3.next = function next(_) {
    if (this.queryID === "") {
      this.queryID = newQueryID();
      this.sequence = 0;
    } else {
      this.sequence++;
    }

    return {
      type: this.type,
      queryID: this.queryID,
      sequence: this.sequence,
      field: this.field,
      data: this.data
    };
  };

  _proto3.reset = function reset() {
    this.emit(EVENT_TRACKING_RESET);
    this.queryID = "";
    this.sequence = 0;
  };

  return DefaultSession;
}(EventEmitter);
/**
 * mergeTrackingData combines the provided session data with the requesters
 * google analytics ID and/or Sajari ID if present in the documents cookie.
 *
 * Because this is meant to be used on the client side, when in SSR mode
 * it will always return empty object
 * @hidden
 */

function mergeTrackingData(data) {
  if (typeof window === "undefined") {
    return {};
  }

  var cookieData = document.cookie.split(";").filter(function (item) {
    return item.includes("_ga") || item.includes("sjID");
  }).map(function (item) {
    return item.split("=");
  }).reduce(function (data, _ref6) {
    var key = _ref6[0],
        val = _ref6[1];

    if (key === "_ga") {
      data["ga"] = val;
      return data;
    }

    data[key] = val;
    return data;
  }, {});

  if (data === undefined) {
    return cookieData;
  }

  Object.entries(cookieData).forEach(function (_ref7) {
    var key = _ref7[0],
        val = _ref7[1];
    data[key] = val;
  });
  return data;
}
/**
 * newQueryID constructs a new ID for a query.
 * @hidden
 */


function newQueryID(len) {
  if (len === void 0) {
    len = 16;
  }

  var output = "";

  for (var i = 0; i < len; i++) {
    output += "abcdefghijklmnopqrstuvwxyz0123456789".charAt(Math.floor(Math.random() * 36));
  }

  return output;
}
/**
 * InteractiveSession creates a session based on text searches and is recommended
 * for use in search-as-you-type style interfaces.
 *
 * It resets the session if the search query value:
 *
 * - Is `undefined`.
 * - First 3 characters have changed (i.e. from a direct replacement)
 * - Cleared after being non-empty (i.e. from a delete)
 */


var InteractiveSession = /*#__PURE__*/function () {
  function InteractiveSession(textParam, session) {
    this.textParam = textParam;
    this.session = session;
    this.lastQuery = "";
  }

  var _proto4 = InteractiveSession.prototype;

  _proto4.next = function next(values) {
    var text = values[this.textParam];

    if (text === undefined) {
      this.reset();
      return this.session.next(values);
    }

    var shortendPreviousQuery = this.lastQuery.substr(0, Math.min(text.length, 3));
    var firstThreeCharsChanged = text.substr(0, shortendPreviousQuery.length) !== shortendPreviousQuery;
    var queryCleared = this.lastQuery.length > 0 && text.length === 0;

    if (firstThreeCharsChanged || queryCleared) {
      this.reset();
    }

    this.lastQuery = text;
    return this.session.next(values);
  };

  _proto4.reset = function reset() {
    this.session.reset();
  };

  return InteractiveSession;
}();
var EVENT_SELECTION_UPDATED = "selection-updated";
var EVENT_OPTIONS_UPDATED = "options-updated";
var Filter = /*#__PURE__*/function (_EventEmitter3) {
  _inheritsLoose(Filter, _EventEmitter3);

  function Filter(options, initial, multi, joinOp) {
    var _this11;

    if (initial === void 0) {
      initial = [];
    }

    if (multi === void 0) {
      multi = false;
    }

    if (joinOp === void 0) {
      joinOp = "OR";
    }

    _this11 = _EventEmitter3.call(this) || this;
    _this11.options = options;
    _this11.active = initial;
    _this11.multi = multi;
    _this11.joinOp = joinOp;
    return _this11;
  }

  var _proto5 = Filter.prototype;

  _proto5.set = function set(key, active) {
    if (active === void 0) {
      active = true;
    }

    if (this.multi) {
      if (active && this.active.indexOf(key) === -1) {
        this.active = this.active.concat(key);
      } else {
        this.active = this.active.filter(function (k) {
          return k !== key;
        });
      }

      this.emit(EVENT_SELECTION_UPDATED, [].concat(this.active));
      return;
    }

    if (active) {
      this.active = [key];
    } else {
      this.active = [];
    }

    this.emit(EVENT_SELECTION_UPDATED, [].concat(this.active));
  };

  _proto5.isActive = function isActive(key) {
    return this.active.indexOf(key) !== -1;
  };

  _proto5.get = function get() {
    return [].concat(this.active);
  };

  _proto5.updateOptions = function updateOptions(options) {
    var _this12 = this;

    Object.keys(options).forEach(function (key) {
      var value = options[key];

      if (value === undefined) {
        delete _this12.options[key];
        _this12.active = _this12.active.filter(function (k) {
          return k !== key;
        });
        return;
      }

      _this12.options[key] = value;
    });
    this.emit(EVENT_OPTIONS_UPDATED, _extends({}, this.options));
  };

  _proto5.getOptions = function getOptions() {
    return _extends({}, this.options);
  };

  _proto5.filter = function filter() {
    var _this13 = this;

    var filters = this.active.map(function (key) {
      var filter = _this13.options[key];

      if (typeof filter === "function") {
        filter = filter();
      }

      if (filter !== "") {
        filter = "(" + filter + ")";
      }

      return filter;
    }).filter(Boolean);

    switch (filters.length) {
      case 0:
        return "";

      case 1:
        return filters[0];

      default:
        return filters.join(" " + this.joinOp + " ");
    }
  };

  return Filter;
}(EventEmitter);
var EVENT_VALUES_UPDATED = "values-changed";
var Values = /*#__PURE__*/function (_EventEmitter4) {
  _inheritsLoose(Values, _EventEmitter4);

  function Values(initial) {
    var _this14;

    if (initial === void 0) {
      initial = {};
    }

    _this14 = _EventEmitter4.call(this) || this;
    _this14.internal = initial;
    return _this14;
  }

  var _proto6 = Values.prototype;

  _proto6._internalUpdate = function _internalUpdate(values) {
    var _this15 = this;

    Object.keys(values).forEach(function (key) {
      var value = values[key];

      if (value === undefined) {
        delete _this15.internal[key];
      } else {
        _this15.internal[key] = value;
      }
    });
  };

  _proto6.update = function update(values) {
    var _this16 = this;

    this._internalUpdate(values);

    this.emit(EVENT_VALUES_UPDATED, values, function (values) {
      return _this16._internalUpdate(values);
    });
  };

  _proto6.get = function get() {
    var values = {};
    Object.entries(this.internal).forEach(function (_ref8) {
      var key = _ref8[0],
          value = _ref8[1];

      if (typeof value === "function") {
        values[key] = value();
      } else if (Array.isArray(value)) {
        values[key] = value.join(",");
      } else {
        values[key] = "" + value;
      }
    });
    return values;
  };

  return Values;
}(EventEmitter);

export { Client, DefaultSession, EVENT_OPTIONS_UPDATED, EVENT_SEARCH_SENT, EVENT_SELECTION_UPDATED, EVENT_TRACKING_RESET, EVENT_VALUES_UPDATED, EventEmitter, Filter, InteractiveSession, NetworkError, PipelineType, RequestError, TrackingType, Values };
//# sourceMappingURL=sajarisdk.esm.js.map
