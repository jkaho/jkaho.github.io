{"version":3,"file":"sajarisdk.umd.production.min.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/ssr.ts","../src/user-agent.ts","../src/index.ts","../src/events.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/**\n * Check if we're in a server-side rendering context\n */\nexport const isSSR = () => typeof window === \"undefined\";\n","// Code Generated. DO NOT EDIT!\n\nimport { isSSR } from \"./ssr\";\n\nconst scriptTag = !isSSR()\n  ? (document.currentScript as HTMLScriptElement | null)?.src\n  : null;\nlet suffix = \"\";\nif (scriptTag) {\n  const source = new URL(scriptTag).host;\n  suffix = `(via ${source})`;\n} else if (isSSR()) {\n  suffix = \"(SSR)\";\n}\n/**\n * user agent of sdk\n * @hidden\n */\nexport const USER_AGENT = [\"sajari-sdk-js/2.0.0-rc.2\", suffix]\n  .filter(Boolean)\n  .join(\" \");\n\n","import { USER_AGENT } from \"./user-agent\";\nimport EventEmitter from \"./events\";\nimport { isSSR } from \"./ssr\";\nexport { EventEmitter };\n\n/**\n * NetworkError defines an error occuring from the network.\n */\nexport class NetworkError extends Error {\n  type: \"CONNECTION\";\n\n  constructor(message: string) {\n    super(message);\n    this.type = \"CONNECTION\";\n  }\n}\n\n/**\n * RequestError defines an error occuring from a request.\n */\nexport class RequestError extends Error {\n  statusCode: number;\n  error?: Error;\n\n  constructor(statusCode: number, message: string, error?: Error) {\n    super(message);\n    this.statusCode = statusCode;\n    this.error = error;\n  }\n}\n\n/**\n * Client defines a client for interacting with the Sajari API.\n */\nexport class Client {\n  project: string;\n  collection: string;\n  endpoint: string;\n  key?: string;\n  secret?: string;\n  // Callers can set this to add an additional user agent value to the request's metadata.\n  userAgent: string = \"\";\n\n  /**\n   * Constructs an instance of Client for a specific project and collection.\n   *\n   * ```javascript\n   * const client = new Client(\"<project>\", \"<collection>\");\n   * ```\n   *\n   * It is also possible to optionally set the api endpoint\n   *\n   * ```javascript\n   * const client = new Client(\"<project>\", \"<collection>\", \"<endpoint>\");\n   * ```\n   *\n   * @param project\n   * @param collection\n   * @param {string} [endpoint]\n   */\n  constructor(\n    project: string,\n    collection: string,\n    endpoint: string = `${isSSR() ? \"https:\" : \"\"}//jsonapi.sajari.net`,\n    key?: string,\n    secret?: string\n  ) {\n    // Key/secret is only allowed in non SSR context\n    if (!isSSR() && [key, secret].some(Boolean)) {\n      throw new Error(\n        \"key/secret authorization is only supported for server-side rendering.\"\n      );\n    }\n\n    this.project = project;\n    this.collection = collection;\n    this.endpoint = endpoint;\n    this.key = key;\n    this.secret = secret;\n    this.interactionConsume = this.interactionConsume.bind(this);\n  }\n\n  /**\n   * call executes a request to the Sajari API\n   */\n  async call<Response = any>(\n    path: string,\n    request: Record<string, any>,\n    signal?: AbortSignal\n  ): Promise<Response> {\n    // Check we have a connection in non SSR context\n    if (!isSSR() && !navigator.onLine) {\n      throw new NetworkError(\n        \"Search request failed due to a network error. Please check your network connection.\"\n      );\n    }\n\n    const metadata = {\n      project: [this.project],\n      collection: [this.collection],\n      \"user-agent\": [[USER_AGENT, this.userAgent].filter(Boolean).join(\" \")],\n    };\n\n    // Only allow key/secret for SSR contexts\n    if (isSSR() && [this.key, this.secret].every(Boolean)) {\n      Object.assign(metadata, {\n        authorization: [`keysecret ${this.key} ${this.secret}`],\n      });\n    }\n\n    const resp = await fetch(`${this.endpoint}${path}`, {\n      signal,\n      method: \"POST\",\n      headers: {\n        Accept: \"application/json\",\n        // XXX: This is to remove the need for the OPTIONS request\n        // https://stackoverflow.com/questions/29954037/why-is-an-options-request-sent-and-can-i-disable-it\n        \"Content-Type\": \"text/plain\",\n      },\n      body: JSON.stringify({\n        metadata,\n        request,\n      }),\n    });\n\n    if (resp.status !== 200) {\n      let message = resp.statusText;\n      try {\n        let response = await resp.json();\n        message = response.message;\n      } catch (_) {}\n\n      if (resp.status === 403) {\n        throw new RequestError(\n          resp.status,\n          \"This domain is not authorized to make this search request.\",\n          new Error(message)\n        );\n      }\n\n      throw new RequestError(\n        resp.status,\n        \"Search request failed due to a configuration error.\",\n        new Error(message)\n      );\n    }\n\n    return await resp.json();\n  }\n\n  /**\n   * pipeline creates a new QueryPipeline instance that inherits configuration from the Client.\n   * @param name pipeline name\n   * @param {string} [version] pipeline version\n   */\n  pipeline(name: string, version?: string): QueryPipeline {\n    return new QueryPipeline(this, name, version);\n  }\n\n  /**\n   * interactionConsume consumes an interaction token.\n   */\n  async interactionConsume(\n    token: string,\n    identifier: string,\n    weight: number,\n    data: Record<string, string> = {}\n  ) {\n    return this.call<void>(\"/sajari.interaction.v2.Interaction/ConsumeToken\", {\n      token,\n      identifier,\n      weight,\n      data,\n    });\n  }\n}\n\n/**\n * Type of pipeline.\n */\nexport enum PipelineType {\n  /**\n   * Query pipeline.\n   */\n  Query = 1,\n  /**\n   * Record pipeline.\n   */\n  Record = 2,\n}\n\nexport interface Step {\n  identifier: string;\n  title?: string;\n  description?: string;\n\n  parameters?: {\n    [name: string]: {\n      name?: string;\n      defaultValue?: string;\n    };\n  };\n  constants?: {\n    [name: string]: {\n      value?: string;\n    };\n  };\n\n  condition?: string;\n}\n\n/**\n * Pipeline ...\n */\nexport interface Pipeline {\n  identifier: PipelineIdentifier;\n  created: Date;\n  description?: string;\n  steps: {\n    preSteps: Step[];\n    postSteps: Step[];\n  };\n}\n\n/**\n * PipelineIdentifier ...\n */\nexport interface PipelineIdentifier {\n  name: string;\n  version?: string;\n}\n\nexport const EVENT_SEARCH_SENT = \"search-sent\";\n\n/**\n * QueryPipeline is a client for running query pipelines on a collection.  See\n * [[QueryPipeline.search]] for more details.\n *\n * Create a new QueryPipeline via [[Client.pipeline]].\n *\n * ```javascript\n * // const client = new Client(...);\n * const pipeline = client.pipeline(\"website\");\n * ```\n */\nclass QueryPipeline extends EventEmitter {\n  private client: Client;\n  readonly identifier: PipelineIdentifier;\n\n  constructor(client: Client, name: string, version?: string) {\n    super();\n    this.client = client;\n    this.identifier = {\n      name: name,\n      version: version,\n    };\n  }\n\n  /**\n   * Search runs a search query defined by a pipeline with the given values and\n   * session configuration.\n   *\n   * ```javascript\n   * pipeline.search({ q: \"<search query>\" })\n   *  .then(([response, values]) => {\n   *    // handle response\n   *  })\n   *  .catch(error => {\n   *    // handle error\n   * })\n   * ```\n   *\n   * @param values\n   * @param tracking\n   */\n  async search(\n    values: Record<string, string>,\n    tracking?: Tracking\n  ): Promise<[SearchResponse, Record<string, string>]> {\n    let pt: TrackingProto = { type: TrackingType.None };\n    if (tracking !== undefined) {\n      const { queryID, ...rest } = tracking;\n      pt = {\n        query_id: queryID,\n        ...rest,\n      };\n    }\n\n    this.emit(EVENT_SEARCH_SENT, values);\n    let jsonProto = await this.client.call<SearchResponseProto>(\n      \"/sajari.api.pipeline.v1.Query/Search\",\n      {\n        pipeline: this.identifier,\n        tracking: pt,\n        values,\n      }\n    );\n\n    const aggregates = Object.entries(\n      jsonProto.searchResponse?.aggregates || {}\n    )\n      .map(([key, aggregate]) => {\n        if (\"metric\" in aggregate) {\n          let [t, k] = key.split(\".\");\n          return {\n            type: t,\n            key: k,\n            value: aggregate.metric.value,\n          };\n        }\n        if (\"count\" in aggregate) {\n          return {\n            type: \"count\",\n            key: key.replace(/^count./, \"\"),\n            value: aggregate.count.counts,\n          };\n        }\n        if (\"buckets\" in aggregate) {\n          return {\n            type: \"count\",\n            key: \"buckets\",\n            value: Object.values(aggregate.buckets?.buckets ?? {}).reduce(\n              (obj, { name, count }) =>\n                Object.assign(obj, {\n                  [name]: count,\n                }),\n              {}\n            ),\n          };\n        }\n        return { key, value: aggregate };\n      })\n      .reduce<Aggregates>((obj, item) => {\n        if (item.type === undefined) {\n          console.debug(item);\n          return obj;\n        }\n\n        if (obj[item.key] === undefined) {\n          obj[item.key] = {};\n        }\n        // @ts-ignore\n        obj[item.key][item.type] = item.value;\n\n        return obj;\n      }, {});\n\n    const aggregateFilters = Object.entries(\n      jsonProto.searchResponse?.aggregateFilters || {}\n    )\n      .map(([key, aggregate]) => {\n        if (\"metric\" in aggregate) {\n          let [t, k] = key.split(\".\");\n          return {\n            type: t,\n            key: k,\n            value: aggregate.metric.value,\n          };\n        }\n        if (\"count\" in aggregate) {\n          return {\n            type: \"count\",\n            key: key.replace(/^count./, \"\"),\n            value: aggregate.count.counts,\n          };\n        }\n        if (\"buckets\" in aggregate) {\n          return {\n            type: \"count\",\n            key: \"buckets\",\n            value: Object.values(aggregate.buckets?.buckets ?? {}).reduce(\n              (obj, { name, count }) =>\n                Object.assign(obj, {\n                  [name]: count,\n                }),\n              {}\n            ),\n          };\n        }\n        return { key, value: aggregate };\n      })\n      .reduce<Aggregates>((obj, item) => {\n        if (item.type === undefined) {\n          console.debug(item);\n          return obj;\n        }\n\n        if (obj[item.key] === undefined) {\n          obj[item.key] = {};\n        }\n        // @ts-ignore\n        obj[item.key][item.type] = item.value;\n\n        return obj;\n      }, {});\n\n    const results: Result[] = (jsonProto.searchResponse?.results || []).map(\n      ({ indexScore, score, values }, index) => {\n        let t: Token | undefined = undefined;\n        const token = (jsonProto.tokens || [])[index];\n        if (token !== undefined) {\n          if (\"click\" in token) {\n            t = { click: clickTokenURL + token.click.token };\n          } else if (\"pos\" in token) {\n            t = { ...token };\n          } else if (\"posNeg\" in token) {\n            t = {\n              pos: token.posNeg.pos,\n              neg: token.posNeg.neg,\n            };\n          }\n        }\n\n        return {\n          indexScore,\n          score,\n          values: processProtoValues(values),\n          token: t,\n        };\n      }\n    );\n\n    return [\n      {\n        time: parseFloat(jsonProto.searchResponse?.time || \"0.0\"),\n        totalResults: parseInt(\n          jsonProto.searchResponse?.totalResults || \"0\",\n          10\n        ),\n        results: results,\n        aggregates: aggregates,\n        aggregateFilters: aggregateFilters,\n      },\n      jsonProto.values || {},\n    ];\n  }\n}\n\n/**\n * Redirect URL for click tracking.  Prepended to the the front of the token\n * returned by the engine.\n * @hidden\n */\nconst clickTokenURL = \"https://re.sajari.com/token/\";\n\nexport interface SearchResponse {\n  /**\n   * Time in seconds taken to perform the query.\n   */\n  time: number;\n\n  /**\n   * totalResults is the total number of results.\n   */\n  totalResults: number;\n\n  /**\n   * Results of the query.\n   */\n  results: Result[];\n\n  /**\n   * Aggregates computed on the query results (see [[Aggregates]]).\n   */\n  aggregates: Aggregates;\n\n  /**\n   * AggregateFilters computed on the query results (see [[Aggregates]]).\n   */\n  aggregateFilters: Aggregates;\n}\n\nexport interface Result {\n  /**\n   * indexScore is the index-matched score of this Result.\n   */\n  indexScore: number;\n  /**\n   * score is the overall score of this [[Result]].\n   */\n  score: number;\n  /**\n   * values is an object of field-value pairs.\n   */\n  values: Record<string, string | string[]>;\n  /**\n   * token is the [[Token]] associated with this [[Result]] (if any).\n   */\n  token?: Token;\n}\n\nexport type Token = ClickToken | PosNegToken;\n\n/**\n * ClickToken defines a click token.  See [[TrackingType.Click]] for more details.\n */\nexport type ClickToken = { click: string };\n\n/**\n * PosNegToken defines a pos/neg token pair. See [[TrackingType.PosNeg]] for more details.\n */\nexport type PosNegToken = { pos: string; neg: string };\n\nexport type Aggregates = Record<\n  string,\n  Record<string, CountAggregate | MetricAggregate>\n>;\n\nexport interface CountAggregate {\n  count: Record<string, number>;\n}\n\nexport type MetricAggregate = number;\n\n/**\n * @hidden\n */\ninterface SearchResponseProto {\n  searchResponse?: Partial<{\n    time: string;\n    totalResults: string;\n    results: ResultProto[];\n    aggregates: AggregatesProto;\n    aggregateFilters: AggregatesProto;\n  }>;\n  tokens?: TokenProto[];\n  values?: Record<string, string>;\n}\n\n/**\n * @hidden\n */\ntype TokenProto =\n  | undefined\n  | {\n      click: { token: string };\n    }\n  | {\n      pos: string;\n      neg: string;\n    }\n  | {\n      posNeg: {\n        pos: string;\n        neg: string;\n      };\n    };\n\n/**\n * @hidden\n */\ntype ValueProto =\n  | { single: string }\n  | { repeated: { values: string[] } }\n  | { null: boolean };\n\n/**\n * @hidden\n */\nfunction processProtoValues(values: Record<string, ValueProto>) {\n  let vs: Record<string, string | string[]> = {};\n  Object.keys(values).forEach((key) => {\n    let v = valueFromProto(values[key]);\n    if (v !== null) {\n      vs[key] = v;\n    }\n  });\n  return vs;\n}\n\n/**\n * @hidden\n */\nfunction valueFromProto(value: ValueProto): string | string[] | null {\n  if (\"single\" in value) {\n    return value.single;\n  } else if (\"repeated\" in value) {\n    return value.repeated.values;\n  }\n  return null;\n}\n\n/**\n * @hidden\n */\ninterface ResultProto {\n  indexScore: number;\n  score: number;\n  values: Record<string, ValueProto>;\n}\n\n/**\n * @hidden\n */\ntype AggregatesProto = Record<\n  string,\n  CountAggregateProto | MetricAggregateProto | BucketAggregateProto\n>;\n\n/**\n * @hidden\n */\ninterface CountAggregateProto {\n  count: {\n    counts: Record<string, number>;\n  };\n}\n\n/**\n * @hidden\n */\ninterface BucketAggregateProto {\n  buckets?: {\n    buckets?: Record<\n      string,\n      {\n        name: string;\n        count: number;\n      }\n    >;\n  };\n}\n\n/**\n * @hidden\n */\ninterface MetricAggregateProto {\n  metric: {\n    value: number;\n  };\n}\n\n/**\n * Tracking defines behaviour for handling search sessions and result interactions.\n */\nexport type Tracking = {\n  type: TrackingType;\n  queryID?: string;\n  sequence?: number;\n  field?: string;\n  data?: Record<string, string>;\n};\n\n/**\n * @hidden\n */\ninterface TrackingProto {\n  type: TrackingType;\n  query_id?: string;\n  sequence?: number;\n  field?: string;\n  data?: Record<string, string>;\n}\n\n/**\n * TrackingType defines the possible result-interaction tracking types used by [[Session]]\n */\nexport enum TrackingType {\n  /**\n   * None disables tracking.\n   */\n  None = \"NONE\",\n  /**\n   * Click generates click tracking tokens.\n   */\n  Click = \"CLICK\",\n  /**\n   * PosNeg creates pos/neg tracking tokens.\n   */\n  PosNeg = \"POS_NEG\",\n}\n\n/**\n * Session takes query values, maintains session state, and returns tracking data\n * to be sent with search requests.\n */\nexport interface Session {\n  /**\n   * next returns [[Tracking]] to be sent with search requests.\n   * @param values\n   */\n  next(values?: Record<string, string>): Tracking;\n\n  /**\n   * reset sets the [[Session]] instance to its empty state.\n   */\n  reset(): void;\n}\n\nexport const EVENT_TRACKING_RESET = \"tracking-reset\";\n\n/**\n * DefaultSession holds state of a sequence of searches.\n */\nexport class DefaultSession extends EventEmitter implements Session {\n  private queryID: string = \"\";\n  private sequence: number = 0;\n\n  private type: TrackingType;\n  private field?: string;\n  private data?: Record<string, string>;\n\n  constructor(\n    type: TrackingType,\n    field?: string,\n    data?: Record<string, string>\n  ) {\n    super();\n    this.type = type;\n    this.field = field;\n    this.data = mergeTrackingData(data);\n  }\n\n  next(_?: Record<string, string>): Tracking {\n    if (this.queryID === \"\") {\n      this.queryID = newQueryID();\n      this.sequence = 0;\n    } else {\n      this.sequence++;\n    }\n\n    return {\n      type: this.type,\n      queryID: this.queryID,\n      sequence: this.sequence,\n      field: this.field,\n      data: this.data,\n    };\n  }\n\n  reset() {\n    this.emit(EVENT_TRACKING_RESET);\n    this.queryID = \"\";\n    this.sequence = 0;\n  }\n}\n\n/**\n * mergeTrackingData combines the provided session data with the requesters\n * google analytics ID and/or Sajari ID if present in the documents cookie.\n *\n * Because this is meant to be used on the client side, when in SSR mode\n * it will always return empty object\n * @hidden\n */\nfunction mergeTrackingData(data?: Record<string, string>) {\n  if (typeof window === \"undefined\") {\n    return {};\n  }\n  const cookieData = document.cookie\n    .split(\";\")\n    .filter((item) => item.includes(\"_ga\") || item.includes(\"sjID\"))\n    .map((item) => item.split(\"=\"))\n    .reduce((data, [key, val]) => {\n      if (key === \"_ga\") {\n        data[\"ga\"] = val;\n        return data;\n      }\n      data[key] = val;\n      return data;\n    }, {} as Record<string, string>);\n\n  if (data === undefined) {\n    return cookieData;\n  }\n\n  Object.entries(cookieData).forEach(([key, val]) => {\n    data[key] = val;\n  });\n\n  return data;\n}\n\n/**\n * newQueryID constructs a new ID for a query.\n * @hidden\n */\nfunction newQueryID(len: number = 16): string {\n  let output = \"\";\n  for (let i = 0; i < len; i++) {\n    output += \"abcdefghijklmnopqrstuvwxyz0123456789\".charAt(\n      Math.floor(Math.random() * 36)\n    );\n  }\n  return output;\n}\n\n/**\n * InteractiveSession creates a session based on text searches and is recommended\n * for use in search-as-you-type style interfaces.\n *\n * It resets the session if the search query value:\n *\n * - Is `undefined`.\n * - First 3 characters have changed (i.e. from a direct replacement)\n * - Cleared after being non-empty (i.e. from a delete)\n */\nexport class InteractiveSession implements Session {\n  private session: Session;\n  private textParam: string;\n  private lastQuery: string;\n\n  constructor(textParam: string, session: Session) {\n    this.textParam = textParam;\n    this.session = session;\n    this.lastQuery = \"\";\n  }\n\n  next(values: Record<string, string>): Tracking {\n    const text = values[this.textParam];\n    if (text === undefined) {\n      this.reset();\n      return this.session.next(values);\n    }\n\n    const shortendPreviousQuery = this.lastQuery.substr(\n      0,\n      Math.min(text.length, 3)\n    );\n    const firstThreeCharsChanged =\n      text.substr(0, shortendPreviousQuery.length) !== shortendPreviousQuery;\n    const queryCleared = this.lastQuery.length > 0 && text.length === 0;\n    if (firstThreeCharsChanged || queryCleared) {\n      this.reset();\n    }\n    this.lastQuery = text;\n\n    return this.session.next(values);\n  }\n\n  reset() {\n    this.session.reset();\n  }\n}\n\ntype FilterFunc = () => string;\n\nexport const EVENT_SELECTION_UPDATED = \"selection-updated\";\nexport const EVENT_OPTIONS_UPDATED = \"options-updated\";\n\nexport class Filter extends EventEmitter {\n  private options: Record<string, string | FilterFunc>;\n  private active: string[];\n  private multi: boolean;\n  private joinOp: \"OR\" | \"AND\";\n\n  constructor(\n    options: Record<string, string>,\n    initial: string[] = [],\n    multi = false,\n    joinOp: \"OR\" | \"AND\" = \"OR\"\n  ) {\n    super();\n    this.options = options;\n    this.active = initial;\n    this.multi = multi;\n    this.joinOp = joinOp;\n  }\n\n  set(key: string, active = true) {\n    if (this.multi) {\n      if (active && this.active.indexOf(key) === -1) {\n        this.active = this.active.concat(key);\n      } else {\n        this.active = this.active.filter((k) => k !== key);\n      }\n      this.emit(EVENT_SELECTION_UPDATED, [...this.active]);\n      return;\n    }\n\n    if (active) {\n      this.active = [key];\n    } else {\n      this.active = [];\n    }\n    this.emit(EVENT_SELECTION_UPDATED, [...this.active]);\n  }\n\n  isActive(key: string): boolean {\n    return this.active.indexOf(key) !== -1;\n  }\n\n  get(): string[] {\n    return [...this.active];\n  }\n\n  updateOptions(options: Record<string, string | FilterFunc | undefined>) {\n    Object.keys(options).forEach((key) => {\n      const value = options[key];\n      if (value === undefined) {\n        delete this.options[key];\n        this.active = this.active.filter((k) => k !== key);\n        return;\n      }\n\n      this.options[key] = value;\n    });\n    this.emit(EVENT_OPTIONS_UPDATED, { ...this.options });\n  }\n\n  getOptions(): Record<string, string | FilterFunc> {\n    return { ...this.options };\n  }\n\n  filter(): string {\n    const filters = this.active\n      .map((key) => {\n        let filter = this.options[key];\n        if (typeof filter === \"function\") {\n          filter = filter();\n        }\n        if (filter !== \"\") {\n          filter = `(${filter})`;\n        }\n        return filter;\n      })\n      .filter(Boolean);\n\n    switch (filters.length) {\n      case 0:\n        return \"\";\n\n      case 1:\n        return filters[0];\n\n      default:\n        return filters.join(` ${this.joinOp} `);\n    }\n  }\n}\n\nexport type ValueFunc = () => string;\nexport type ValueType =\n  | string\n  | number\n  | boolean\n  | string[]\n  | number[]\n  | boolean[]\n  | ValueFunc;\n\nexport const EVENT_VALUES_UPDATED = \"values-changed\";\n\nexport class Values extends EventEmitter {\n  private internal: Record<string, ValueType>;\n\n  constructor(initial: Record<string, ValueType> = {}) {\n    super();\n    this.internal = initial;\n  }\n\n  _internalUpdate(values: Record<string, ValueType | undefined>) {\n    Object.keys(values).forEach((key) => {\n      const value = values[key];\n      if (value === undefined) {\n        delete this.internal[key];\n      } else {\n        this.internal[key] = value;\n      }\n    });\n  }\n\n  update(values: Record<string, ValueType | undefined>) {\n    this._internalUpdate(values);\n    this.emit(\n      EVENT_VALUES_UPDATED,\n      values,\n      (values: Record<string, ValueType | undefined>) =>\n        this._internalUpdate(values)\n    );\n  }\n\n  get(): Record<string, string> {\n    const values: Record<string, string> = {};\n    Object.entries(this.internal).forEach(([key, value]) => {\n      if (typeof value === \"function\") {\n        values[key] = value();\n      } else if (Array.isArray(value)) {\n        values[key] = value.join(\",\");\n      } else {\n        values[key] = \"\" + value;\n      }\n    });\n\n    return values;\n  }\n}\n","export type SubCallback = (...data: any) => void;\nexport type UnSubFn = () => void;\n\nexport default class EventEmitter {\n  private events: Record<string, SubCallback[]> = {};\n\n  protected emit(event: string, ...data: any) {\n    if (this.events[\"*\"]) {\n      this.events[\"*\"].forEach(cb => cb(event, ...data));\n    }\n    if (!this.events[event]) {\n      return;\n    }\n\n    this.events[event].forEach(cb => cb(...data));\n  }\n\n  public on(event: string, callback: SubCallback): UnSubFn {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n\n    return () => {\n      this.events[event] = this.events[event].filter(item => item !== callback);\n    };\n  }\n}\n"],"names":["Symbol","iterator","asyncIterator","isSSR","window","scriptTag","document","currentScript","_document$currentScri","src","suffix","URL","host","PipelineType","USER_AGENT","filter","Boolean","join","EventEmitter","emit","event","data","this","events","forEach","cb","on","callback","push","_this","item","NetworkError","message","type","Error","RequestError","statusCode","error","Client","project","collection","endpoint","key","secret","some","interactionConsume","bind","call","path","request","signal","navigator","onLine","metadata","userAgent","every","Object","assign","authorization","fetch","method","headers","Accept","body","JSON","stringify","resp","json","status","statusText","recover","result","response","e","then","pipeline","name","version","QueryPipeline","token","identifier","weight","TrackingType","client","search","values","tracking","pt","None","undefined","query_id","queryID","jsonProto","aggregates","entries","searchResponse","map","aggregate","split","value","metric","replace","count","counts","buckets","_aggregate$buckets","reduce","obj","console","debug","aggregateFilters","_aggregate$buckets2","results","index","indexScore","score","t","tokens","click","clickTokenURL","pos","posNeg","neg","processProtoValues","time","parseFloat","totalResults","parseInt","vs","keys","v","single","repeated","DefaultSession","field","cookieData","cookie","includes","val","mergeTrackingData","next","_","len","output","i","charAt","Math","floor","random","newQueryID","sequence","reset","InteractiveSession","textParam","session","lastQuery","text","shortendPreviousQuery","substr","min","length","Filter","options","initial","multi","joinOp","active","set","indexOf","concat","k","isActive","get","updateOptions","_this12","getOptions","filters","_this13","Values","internal","_internalUpdate","_this15","update","_this16","Array","isArray"],"mappings":"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"}