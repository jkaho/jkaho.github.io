{"version":3,"file":"sajarisdk.esm.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/ssr.ts","../src/user-agent.ts","../src/events.ts","../src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/**\n * Check if we're in a server-side rendering context\n */\nexport const isSSR = () => typeof window === \"undefined\";\n","// Code Generated. DO NOT EDIT!\n\nimport { isSSR } from \"./ssr\";\n\nconst scriptTag = !isSSR()\n  ? (document.currentScript as HTMLScriptElement | null)?.src\n  : null;\nlet suffix = \"\";\nif (scriptTag) {\n  const source = new URL(scriptTag).host;\n  suffix = `(via ${source})`;\n} else if (isSSR()) {\n  suffix = \"(SSR)\";\n}\n/**\n * user agent of sdk\n * @hidden\n */\nexport const USER_AGENT = [\"sajari-sdk-js/2.0.0-rc.2\", suffix]\n  .filter(Boolean)\n  .join(\" \");\n\n","export type SubCallback = (...data: any) => void;\nexport type UnSubFn = () => void;\n\nexport default class EventEmitter {\n  private events: Record<string, SubCallback[]> = {};\n\n  protected emit(event: string, ...data: any) {\n    if (this.events[\"*\"]) {\n      this.events[\"*\"].forEach(cb => cb(event, ...data));\n    }\n    if (!this.events[event]) {\n      return;\n    }\n\n    this.events[event].forEach(cb => cb(...data));\n  }\n\n  public on(event: string, callback: SubCallback): UnSubFn {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n\n    return () => {\n      this.events[event] = this.events[event].filter(item => item !== callback);\n    };\n  }\n}\n","import { USER_AGENT } from \"./user-agent\";\nimport EventEmitter from \"./events\";\nimport { isSSR } from \"./ssr\";\nexport { EventEmitter };\n\n/**\n * NetworkError defines an error occuring from the network.\n */\nexport class NetworkError extends Error {\n  type: \"CONNECTION\";\n\n  constructor(message: string) {\n    super(message);\n    this.type = \"CONNECTION\";\n  }\n}\n\n/**\n * RequestError defines an error occuring from a request.\n */\nexport class RequestError extends Error {\n  statusCode: number;\n  error?: Error;\n\n  constructor(statusCode: number, message: string, error?: Error) {\n    super(message);\n    this.statusCode = statusCode;\n    this.error = error;\n  }\n}\n\n/**\n * Client defines a client for interacting with the Sajari API.\n */\nexport class Client {\n  project: string;\n  collection: string;\n  endpoint: string;\n  key?: string;\n  secret?: string;\n  // Callers can set this to add an additional user agent value to the request's metadata.\n  userAgent: string = \"\";\n\n  /**\n   * Constructs an instance of Client for a specific project and collection.\n   *\n   * ```javascript\n   * const client = new Client(\"<project>\", \"<collection>\");\n   * ```\n   *\n   * It is also possible to optionally set the api endpoint\n   *\n   * ```javascript\n   * const client = new Client(\"<project>\", \"<collection>\", \"<endpoint>\");\n   * ```\n   *\n   * @param project\n   * @param collection\n   * @param {string} [endpoint]\n   */\n  constructor(\n    project: string,\n    collection: string,\n    endpoint: string = `${isSSR() ? \"https:\" : \"\"}//jsonapi.sajari.net`,\n    key?: string,\n    secret?: string\n  ) {\n    // Key/secret is only allowed in non SSR context\n    if (!isSSR() && [key, secret].some(Boolean)) {\n      throw new Error(\n        \"key/secret authorization is only supported for server-side rendering.\"\n      );\n    }\n\n    this.project = project;\n    this.collection = collection;\n    this.endpoint = endpoint;\n    this.key = key;\n    this.secret = secret;\n    this.interactionConsume = this.interactionConsume.bind(this);\n  }\n\n  /**\n   * call executes a request to the Sajari API\n   */\n  async call<Response = any>(\n    path: string,\n    request: Record<string, any>,\n    signal?: AbortSignal\n  ): Promise<Response> {\n    // Check we have a connection in non SSR context\n    if (!isSSR() && !navigator.onLine) {\n      throw new NetworkError(\n        \"Search request failed due to a network error. Please check your network connection.\"\n      );\n    }\n\n    const metadata = {\n      project: [this.project],\n      collection: [this.collection],\n      \"user-agent\": [[USER_AGENT, this.userAgent].filter(Boolean).join(\" \")],\n    };\n\n    // Only allow key/secret for SSR contexts\n    if (isSSR() && [this.key, this.secret].every(Boolean)) {\n      Object.assign(metadata, {\n        authorization: [`keysecret ${this.key} ${this.secret}`],\n      });\n    }\n\n    const resp = await fetch(`${this.endpoint}${path}`, {\n      signal,\n      method: \"POST\",\n      headers: {\n        Accept: \"application/json\",\n        // XXX: This is to remove the need for the OPTIONS request\n        // https://stackoverflow.com/questions/29954037/why-is-an-options-request-sent-and-can-i-disable-it\n        \"Content-Type\": \"text/plain\",\n      },\n      body: JSON.stringify({\n        metadata,\n        request,\n      }),\n    });\n\n    if (resp.status !== 200) {\n      let message = resp.statusText;\n      try {\n        let response = await resp.json();\n        message = response.message;\n      } catch (_) {}\n\n      if (resp.status === 403) {\n        throw new RequestError(\n          resp.status,\n          \"This domain is not authorized to make this search request.\",\n          new Error(message)\n        );\n      }\n\n      throw new RequestError(\n        resp.status,\n        \"Search request failed due to a configuration error.\",\n        new Error(message)\n      );\n    }\n\n    return await resp.json();\n  }\n\n  /**\n   * pipeline creates a new QueryPipeline instance that inherits configuration from the Client.\n   * @param name pipeline name\n   * @param {string} [version] pipeline version\n   */\n  pipeline(name: string, version?: string): QueryPipeline {\n    return new QueryPipeline(this, name, version);\n  }\n\n  /**\n   * interactionConsume consumes an interaction token.\n   */\n  async interactionConsume(\n    token: string,\n    identifier: string,\n    weight: number,\n    data: Record<string, string> = {}\n  ) {\n    return this.call<void>(\"/sajari.interaction.v2.Interaction/ConsumeToken\", {\n      token,\n      identifier,\n      weight,\n      data,\n    });\n  }\n}\n\n/**\n * Type of pipeline.\n */\nexport enum PipelineType {\n  /**\n   * Query pipeline.\n   */\n  Query = 1,\n  /**\n   * Record pipeline.\n   */\n  Record = 2,\n}\n\nexport interface Step {\n  identifier: string;\n  title?: string;\n  description?: string;\n\n  parameters?: {\n    [name: string]: {\n      name?: string;\n      defaultValue?: string;\n    };\n  };\n  constants?: {\n    [name: string]: {\n      value?: string;\n    };\n  };\n\n  condition?: string;\n}\n\n/**\n * Pipeline ...\n */\nexport interface Pipeline {\n  identifier: PipelineIdentifier;\n  created: Date;\n  description?: string;\n  steps: {\n    preSteps: Step[];\n    postSteps: Step[];\n  };\n}\n\n/**\n * PipelineIdentifier ...\n */\nexport interface PipelineIdentifier {\n  name: string;\n  version?: string;\n}\n\nexport const EVENT_SEARCH_SENT = \"search-sent\";\n\n/**\n * QueryPipeline is a client for running query pipelines on a collection.  See\n * [[QueryPipeline.search]] for more details.\n *\n * Create a new QueryPipeline via [[Client.pipeline]].\n *\n * ```javascript\n * // const client = new Client(...);\n * const pipeline = client.pipeline(\"website\");\n * ```\n */\nclass QueryPipeline extends EventEmitter {\n  private client: Client;\n  readonly identifier: PipelineIdentifier;\n\n  constructor(client: Client, name: string, version?: string) {\n    super();\n    this.client = client;\n    this.identifier = {\n      name: name,\n      version: version,\n    };\n  }\n\n  /**\n   * Search runs a search query defined by a pipeline with the given values and\n   * session configuration.\n   *\n   * ```javascript\n   * pipeline.search({ q: \"<search query>\" })\n   *  .then(([response, values]) => {\n   *    // handle response\n   *  })\n   *  .catch(error => {\n   *    // handle error\n   * })\n   * ```\n   *\n   * @param values\n   * @param tracking\n   */\n  async search(\n    values: Record<string, string>,\n    tracking?: Tracking\n  ): Promise<[SearchResponse, Record<string, string>]> {\n    let pt: TrackingProto = { type: TrackingType.None };\n    if (tracking !== undefined) {\n      const { queryID, ...rest } = tracking;\n      pt = {\n        query_id: queryID,\n        ...rest,\n      };\n    }\n\n    this.emit(EVENT_SEARCH_SENT, values);\n    let jsonProto = await this.client.call<SearchResponseProto>(\n      \"/sajari.api.pipeline.v1.Query/Search\",\n      {\n        pipeline: this.identifier,\n        tracking: pt,\n        values,\n      }\n    );\n\n    const aggregates = Object.entries(\n      jsonProto.searchResponse?.aggregates || {}\n    )\n      .map(([key, aggregate]) => {\n        if (\"metric\" in aggregate) {\n          let [t, k] = key.split(\".\");\n          return {\n            type: t,\n            key: k,\n            value: aggregate.metric.value,\n          };\n        }\n        if (\"count\" in aggregate) {\n          return {\n            type: \"count\",\n            key: key.replace(/^count./, \"\"),\n            value: aggregate.count.counts,\n          };\n        }\n        if (\"buckets\" in aggregate) {\n          return {\n            type: \"count\",\n            key: \"buckets\",\n            value: Object.values(aggregate.buckets?.buckets ?? {}).reduce(\n              (obj, { name, count }) =>\n                Object.assign(obj, {\n                  [name]: count,\n                }),\n              {}\n            ),\n          };\n        }\n        return { key, value: aggregate };\n      })\n      .reduce<Aggregates>((obj, item) => {\n        if (item.type === undefined) {\n          console.debug(item);\n          return obj;\n        }\n\n        if (obj[item.key] === undefined) {\n          obj[item.key] = {};\n        }\n        // @ts-ignore\n        obj[item.key][item.type] = item.value;\n\n        return obj;\n      }, {});\n\n    const aggregateFilters = Object.entries(\n      jsonProto.searchResponse?.aggregateFilters || {}\n    )\n      .map(([key, aggregate]) => {\n        if (\"metric\" in aggregate) {\n          let [t, k] = key.split(\".\");\n          return {\n            type: t,\n            key: k,\n            value: aggregate.metric.value,\n          };\n        }\n        if (\"count\" in aggregate) {\n          return {\n            type: \"count\",\n            key: key.replace(/^count./, \"\"),\n            value: aggregate.count.counts,\n          };\n        }\n        if (\"buckets\" in aggregate) {\n          return {\n            type: \"count\",\n            key: \"buckets\",\n            value: Object.values(aggregate.buckets?.buckets ?? {}).reduce(\n              (obj, { name, count }) =>\n                Object.assign(obj, {\n                  [name]: count,\n                }),\n              {}\n            ),\n          };\n        }\n        return { key, value: aggregate };\n      })\n      .reduce<Aggregates>((obj, item) => {\n        if (item.type === undefined) {\n          console.debug(item);\n          return obj;\n        }\n\n        if (obj[item.key] === undefined) {\n          obj[item.key] = {};\n        }\n        // @ts-ignore\n        obj[item.key][item.type] = item.value;\n\n        return obj;\n      }, {});\n\n    const results: Result[] = (jsonProto.searchResponse?.results || []).map(\n      ({ indexScore, score, values }, index) => {\n        let t: Token | undefined = undefined;\n        const token = (jsonProto.tokens || [])[index];\n        if (token !== undefined) {\n          if (\"click\" in token) {\n            t = { click: clickTokenURL + token.click.token };\n          } else if (\"pos\" in token) {\n            t = { ...token };\n          } else if (\"posNeg\" in token) {\n            t = {\n              pos: token.posNeg.pos,\n              neg: token.posNeg.neg,\n            };\n          }\n        }\n\n        return {\n          indexScore,\n          score,\n          values: processProtoValues(values),\n          token: t,\n        };\n      }\n    );\n\n    return [\n      {\n        time: parseFloat(jsonProto.searchResponse?.time || \"0.0\"),\n        totalResults: parseInt(\n          jsonProto.searchResponse?.totalResults || \"0\",\n          10\n        ),\n        results: results,\n        aggregates: aggregates,\n        aggregateFilters: aggregateFilters,\n      },\n      jsonProto.values || {},\n    ];\n  }\n}\n\n/**\n * Redirect URL for click tracking.  Prepended to the the front of the token\n * returned by the engine.\n * @hidden\n */\nconst clickTokenURL = \"https://re.sajari.com/token/\";\n\nexport interface SearchResponse {\n  /**\n   * Time in seconds taken to perform the query.\n   */\n  time: number;\n\n  /**\n   * totalResults is the total number of results.\n   */\n  totalResults: number;\n\n  /**\n   * Results of the query.\n   */\n  results: Result[];\n\n  /**\n   * Aggregates computed on the query results (see [[Aggregates]]).\n   */\n  aggregates: Aggregates;\n\n  /**\n   * AggregateFilters computed on the query results (see [[Aggregates]]).\n   */\n  aggregateFilters: Aggregates;\n}\n\nexport interface Result {\n  /**\n   * indexScore is the index-matched score of this Result.\n   */\n  indexScore: number;\n  /**\n   * score is the overall score of this [[Result]].\n   */\n  score: number;\n  /**\n   * values is an object of field-value pairs.\n   */\n  values: Record<string, string | string[]>;\n  /**\n   * token is the [[Token]] associated with this [[Result]] (if any).\n   */\n  token?: Token;\n}\n\nexport type Token = ClickToken | PosNegToken;\n\n/**\n * ClickToken defines a click token.  See [[TrackingType.Click]] for more details.\n */\nexport type ClickToken = { click: string };\n\n/**\n * PosNegToken defines a pos/neg token pair. See [[TrackingType.PosNeg]] for more details.\n */\nexport type PosNegToken = { pos: string; neg: string };\n\nexport type Aggregates = Record<\n  string,\n  Record<string, CountAggregate | MetricAggregate>\n>;\n\nexport interface CountAggregate {\n  count: Record<string, number>;\n}\n\nexport type MetricAggregate = number;\n\n/**\n * @hidden\n */\ninterface SearchResponseProto {\n  searchResponse?: Partial<{\n    time: string;\n    totalResults: string;\n    results: ResultProto[];\n    aggregates: AggregatesProto;\n    aggregateFilters: AggregatesProto;\n  }>;\n  tokens?: TokenProto[];\n  values?: Record<string, string>;\n}\n\n/**\n * @hidden\n */\ntype TokenProto =\n  | undefined\n  | {\n      click: { token: string };\n    }\n  | {\n      pos: string;\n      neg: string;\n    }\n  | {\n      posNeg: {\n        pos: string;\n        neg: string;\n      };\n    };\n\n/**\n * @hidden\n */\ntype ValueProto =\n  | { single: string }\n  | { repeated: { values: string[] } }\n  | { null: boolean };\n\n/**\n * @hidden\n */\nfunction processProtoValues(values: Record<string, ValueProto>) {\n  let vs: Record<string, string | string[]> = {};\n  Object.keys(values).forEach((key) => {\n    let v = valueFromProto(values[key]);\n    if (v !== null) {\n      vs[key] = v;\n    }\n  });\n  return vs;\n}\n\n/**\n * @hidden\n */\nfunction valueFromProto(value: ValueProto): string | string[] | null {\n  if (\"single\" in value) {\n    return value.single;\n  } else if (\"repeated\" in value) {\n    return value.repeated.values;\n  }\n  return null;\n}\n\n/**\n * @hidden\n */\ninterface ResultProto {\n  indexScore: number;\n  score: number;\n  values: Record<string, ValueProto>;\n}\n\n/**\n * @hidden\n */\ntype AggregatesProto = Record<\n  string,\n  CountAggregateProto | MetricAggregateProto | BucketAggregateProto\n>;\n\n/**\n * @hidden\n */\ninterface CountAggregateProto {\n  count: {\n    counts: Record<string, number>;\n  };\n}\n\n/**\n * @hidden\n */\ninterface BucketAggregateProto {\n  buckets?: {\n    buckets?: Record<\n      string,\n      {\n        name: string;\n        count: number;\n      }\n    >;\n  };\n}\n\n/**\n * @hidden\n */\ninterface MetricAggregateProto {\n  metric: {\n    value: number;\n  };\n}\n\n/**\n * Tracking defines behaviour for handling search sessions and result interactions.\n */\nexport type Tracking = {\n  type: TrackingType;\n  queryID?: string;\n  sequence?: number;\n  field?: string;\n  data?: Record<string, string>;\n};\n\n/**\n * @hidden\n */\ninterface TrackingProto {\n  type: TrackingType;\n  query_id?: string;\n  sequence?: number;\n  field?: string;\n  data?: Record<string, string>;\n}\n\n/**\n * TrackingType defines the possible result-interaction tracking types used by [[Session]]\n */\nexport enum TrackingType {\n  /**\n   * None disables tracking.\n   */\n  None = \"NONE\",\n  /**\n   * Click generates click tracking tokens.\n   */\n  Click = \"CLICK\",\n  /**\n   * PosNeg creates pos/neg tracking tokens.\n   */\n  PosNeg = \"POS_NEG\",\n}\n\n/**\n * Session takes query values, maintains session state, and returns tracking data\n * to be sent with search requests.\n */\nexport interface Session {\n  /**\n   * next returns [[Tracking]] to be sent with search requests.\n   * @param values\n   */\n  next(values?: Record<string, string>): Tracking;\n\n  /**\n   * reset sets the [[Session]] instance to its empty state.\n   */\n  reset(): void;\n}\n\nexport const EVENT_TRACKING_RESET = \"tracking-reset\";\n\n/**\n * DefaultSession holds state of a sequence of searches.\n */\nexport class DefaultSession extends EventEmitter implements Session {\n  private queryID: string = \"\";\n  private sequence: number = 0;\n\n  private type: TrackingType;\n  private field?: string;\n  private data?: Record<string, string>;\n\n  constructor(\n    type: TrackingType,\n    field?: string,\n    data?: Record<string, string>\n  ) {\n    super();\n    this.type = type;\n    this.field = field;\n    this.data = mergeTrackingData(data);\n  }\n\n  next(_?: Record<string, string>): Tracking {\n    if (this.queryID === \"\") {\n      this.queryID = newQueryID();\n      this.sequence = 0;\n    } else {\n      this.sequence++;\n    }\n\n    return {\n      type: this.type,\n      queryID: this.queryID,\n      sequence: this.sequence,\n      field: this.field,\n      data: this.data,\n    };\n  }\n\n  reset() {\n    this.emit(EVENT_TRACKING_RESET);\n    this.queryID = \"\";\n    this.sequence = 0;\n  }\n}\n\n/**\n * mergeTrackingData combines the provided session data with the requesters\n * google analytics ID and/or Sajari ID if present in the documents cookie.\n *\n * Because this is meant to be used on the client side, when in SSR mode\n * it will always return empty object\n * @hidden\n */\nfunction mergeTrackingData(data?: Record<string, string>) {\n  if (typeof window === \"undefined\") {\n    return {};\n  }\n  const cookieData = document.cookie\n    .split(\";\")\n    .filter((item) => item.includes(\"_ga\") || item.includes(\"sjID\"))\n    .map((item) => item.split(\"=\"))\n    .reduce((data, [key, val]) => {\n      if (key === \"_ga\") {\n        data[\"ga\"] = val;\n        return data;\n      }\n      data[key] = val;\n      return data;\n    }, {} as Record<string, string>);\n\n  if (data === undefined) {\n    return cookieData;\n  }\n\n  Object.entries(cookieData).forEach(([key, val]) => {\n    data[key] = val;\n  });\n\n  return data;\n}\n\n/**\n * newQueryID constructs a new ID for a query.\n * @hidden\n */\nfunction newQueryID(len: number = 16): string {\n  let output = \"\";\n  for (let i = 0; i < len; i++) {\n    output += \"abcdefghijklmnopqrstuvwxyz0123456789\".charAt(\n      Math.floor(Math.random() * 36)\n    );\n  }\n  return output;\n}\n\n/**\n * InteractiveSession creates a session based on text searches and is recommended\n * for use in search-as-you-type style interfaces.\n *\n * It resets the session if the search query value:\n *\n * - Is `undefined`.\n * - First 3 characters have changed (i.e. from a direct replacement)\n * - Cleared after being non-empty (i.e. from a delete)\n */\nexport class InteractiveSession implements Session {\n  private session: Session;\n  private textParam: string;\n  private lastQuery: string;\n\n  constructor(textParam: string, session: Session) {\n    this.textParam = textParam;\n    this.session = session;\n    this.lastQuery = \"\";\n  }\n\n  next(values: Record<string, string>): Tracking {\n    const text = values[this.textParam];\n    if (text === undefined) {\n      this.reset();\n      return this.session.next(values);\n    }\n\n    const shortendPreviousQuery = this.lastQuery.substr(\n      0,\n      Math.min(text.length, 3)\n    );\n    const firstThreeCharsChanged =\n      text.substr(0, shortendPreviousQuery.length) !== shortendPreviousQuery;\n    const queryCleared = this.lastQuery.length > 0 && text.length === 0;\n    if (firstThreeCharsChanged || queryCleared) {\n      this.reset();\n    }\n    this.lastQuery = text;\n\n    return this.session.next(values);\n  }\n\n  reset() {\n    this.session.reset();\n  }\n}\n\ntype FilterFunc = () => string;\n\nexport const EVENT_SELECTION_UPDATED = \"selection-updated\";\nexport const EVENT_OPTIONS_UPDATED = \"options-updated\";\n\nexport class Filter extends EventEmitter {\n  private options: Record<string, string | FilterFunc>;\n  private active: string[];\n  private multi: boolean;\n  private joinOp: \"OR\" | \"AND\";\n\n  constructor(\n    options: Record<string, string>,\n    initial: string[] = [],\n    multi = false,\n    joinOp: \"OR\" | \"AND\" = \"OR\"\n  ) {\n    super();\n    this.options = options;\n    this.active = initial;\n    this.multi = multi;\n    this.joinOp = joinOp;\n  }\n\n  set(key: string, active = true) {\n    if (this.multi) {\n      if (active && this.active.indexOf(key) === -1) {\n        this.active = this.active.concat(key);\n      } else {\n        this.active = this.active.filter((k) => k !== key);\n      }\n      this.emit(EVENT_SELECTION_UPDATED, [...this.active]);\n      return;\n    }\n\n    if (active) {\n      this.active = [key];\n    } else {\n      this.active = [];\n    }\n    this.emit(EVENT_SELECTION_UPDATED, [...this.active]);\n  }\n\n  isActive(key: string): boolean {\n    return this.active.indexOf(key) !== -1;\n  }\n\n  get(): string[] {\n    return [...this.active];\n  }\n\n  updateOptions(options: Record<string, string | FilterFunc | undefined>) {\n    Object.keys(options).forEach((key) => {\n      const value = options[key];\n      if (value === undefined) {\n        delete this.options[key];\n        this.active = this.active.filter((k) => k !== key);\n        return;\n      }\n\n      this.options[key] = value;\n    });\n    this.emit(EVENT_OPTIONS_UPDATED, { ...this.options });\n  }\n\n  getOptions(): Record<string, string | FilterFunc> {\n    return { ...this.options };\n  }\n\n  filter(): string {\n    const filters = this.active\n      .map((key) => {\n        let filter = this.options[key];\n        if (typeof filter === \"function\") {\n          filter = filter();\n        }\n        if (filter !== \"\") {\n          filter = `(${filter})`;\n        }\n        return filter;\n      })\n      .filter(Boolean);\n\n    switch (filters.length) {\n      case 0:\n        return \"\";\n\n      case 1:\n        return filters[0];\n\n      default:\n        return filters.join(` ${this.joinOp} `);\n    }\n  }\n}\n\nexport type ValueFunc = () => string;\nexport type ValueType =\n  | string\n  | number\n  | boolean\n  | string[]\n  | number[]\n  | boolean[]\n  | ValueFunc;\n\nexport const EVENT_VALUES_UPDATED = \"values-changed\";\n\nexport class Values extends EventEmitter {\n  private internal: Record<string, ValueType>;\n\n  constructor(initial: Record<string, ValueType> = {}) {\n    super();\n    this.internal = initial;\n  }\n\n  _internalUpdate(values: Record<string, ValueType | undefined>) {\n    Object.keys(values).forEach((key) => {\n      const value = values[key];\n      if (value === undefined) {\n        delete this.internal[key];\n      } else {\n        this.internal[key] = value;\n      }\n    });\n  }\n\n  update(values: Record<string, ValueType | undefined>) {\n    this._internalUpdate(values);\n    this.emit(\n      EVENT_VALUES_UPDATED,\n      values,\n      (values: Record<string, ValueType | undefined>) =>\n        this._internalUpdate(values)\n    );\n  }\n\n  get(): Record<string, string> {\n    const values: Record<string, string> = {};\n    Object.entries(this.internal).forEach(([key, value]) => {\n      if (typeof value === \"function\") {\n        values[key] = value();\n      } else if (Array.isArray(value)) {\n        values[key] = value.join(\",\");\n      } else {\n        values[key] = \"\" + value;\n      }\n    });\n\n    return values;\n  }\n}\n"],"names":["isSSR","window","scriptTag","document","currentScript","src","suffix","source","URL","host","USER_AGENT","filter","Boolean","join","EventEmitter","emit","event","data","events","forEach","cb","on","callback","push","item","NetworkError","message","type","Error","RequestError","statusCode","error","Client","project","collection","endpoint","key","secret","some","interactionConsume","bind","call","path","request","signal","navigator","onLine","metadata","userAgent","every","Object","assign","authorization","fetch","method","headers","Accept","body","JSON","stringify","resp","json","status","statusText","response","pipeline","name","version","QueryPipeline","token","identifier","weight","PipelineType","EVENT_SEARCH_SENT","client","search","values","tracking","pt","TrackingType","None","undefined","queryID","rest","query_id","jsonProto","aggregates","entries","searchResponse","map","aggregate","split","t","k","value","metric","replace","count","counts","buckets","reduce","obj","console","debug","aggregateFilters","results","index","indexScore","score","tokens","click","clickTokenURL","pos","posNeg","neg","processProtoValues","time","parseFloat","totalResults","parseInt","vs","keys","v","valueFromProto","single","repeated","EVENT_TRACKING_RESET","DefaultSession","field","mergeTrackingData","next","_","newQueryID","sequence","reset","cookieData","cookie","includes","val","len","output","i","charAt","Math","floor","random","InteractiveSession","textParam","session","lastQuery","text","shortendPreviousQuery","substr","min","length","firstThreeCharsChanged","queryCleared","EVENT_SELECTION_UPDATED","EVENT_OPTIONS_UPDATED","Filter","options","initial","multi","joinOp","active","set","indexOf","concat","isActive","get","updateOptions","getOptions","filters","EVENT_VALUES_UPDATED","Values","internal","_internalUpdate","update","Array","isArray"],"mappings":"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"}